\section{LiTS: A Unified Grammar}
LiTS abstracts three task types—
\textbf{Environment Grounded} (e.g., BlocksWorld), 
\textbf{Language Grounded} (e.g., Math QA), 
and \textbf{Tool Use} (e.g., MapEval)—to 
unify diverse LLM reasoning paradigms.

Figure 1 presents a container view of subpackages. 
Each subpackage (or container) is a 
separately deployable or runnable unit 
with dependencies on the left or/and bottom containers.

\paragraph{Design Goals.}
LiTS separates low-level task-specific definitions 
(components and prompts) from search algorithm implementations.
This design achieves two key goals:
(1) Search algorithms (BFS, MCTS, etc.) can be reused across 
diverse task types without modification, 
enabled by the high-level \code{lits.structures} 
that standardize communication between components.
(2) Low-level task-specific implementations 
(\code{lits.components} and \code{lits.prompts}) 
can be reused or customized depending on users' needs, 
benefiting from our task-instance-prioritized, 
task-type-aware-fallback prompt registry design.
The paragraphs below demonstrate the specific design 
over the above mentioned three subpackages.

% Writing note: Paragraphs below answer the following two questions:
% 1. which general interface/data type/strcuture we use? 
%    (I am not sure whether should I call Step, Action, .... 
%    data types or data structure)
% 2. which task-specific implementations are hidden under 
%    such general interface/data type/structure? 


\paragraph{lits.structures: General Data Structures 
for Algorithm Reuse (Goal 1).}
The framework establishes a hierarchical type system: 
Action $\rightarrow$ Step $\rightarrow$ State $\rightarrow$ Node. 
Each level defines a \textbf{general interface} with 
\textit{polymorphic subclasses} for task-specific behavior.
Search algorithms operate on these interfaces 
without knowing the underlying implementations.

\begin{itemize}
\item \textbf{Action} (general interface): 
The atomic unit generated by Policy.
\textit{Polymorphic subclasses}: 
\code{StringAction} (free-form text), 
\code{ToolUseAction} (tool invocation), 
\code{EnvAction} (environment interaction).

\item \textbf{Step} (general interface): 
Encapsulates an action with its execution results (if any).
\textit{Polymorphic subclasses}:
    \begin{itemize}
        \item \code{ThoughtStep}: 
              Reasoning step (action only, no execution).
        \item \code{ToolUseStep}: 
              Thought-action-observation cycle.
        \item \code{EnvStep}: 
              Action with resulting environment snapshot.
        \item \code{SubQAStep}: 
              Sub-question and sub-answer pair for RAP.
    \end{itemize}

\item \textbf{State} (general interface): 
Accumulation of steps over time, with unified rendering methods.
\textit{Polymorphic subclasses}: 
\code{EnvState} (tracks environment snapshots), 
\code{ToolUseState} (tracks tool execution history).

\item \textbf{Node} (general interface): 
Search-oriented wrapper managing parent pointers, children, 
rewards, and visit counts for search algorithms.
\textit{Polymorphic subclasses}: 
None required—operates on any State subclass.
\end{itemize}

This design decouples search algorithms from task-specific logic. 
Researchers implement new reasoning domains by defining 
task-specific Action, Step, and State subclasses, 
while reusing the same search pipelines (BFS, MCTS, etc.).


% Writing note: lits.components uses the same polymorphism pattern as 
% lits.structures (agents call general interfaces like Policy.get_actions(), 
% subclasses provide task-specific behavior). We introduce "polymorphic 
% subclasses" in lits.structures, then use shorter "subclasses" here 
% to reduce jargon repetition while maintaining conceptual consistency.

\paragraph{lits.components: Modular LLM Components (Goal 2).}
LiTS decomposes LLM-based reasoning into three modular components.
Each component defines a \textbf{general interface} with 
task-specific subclasses:

\begin{itemize}
\item \textbf{Policy} (general interface): 
Generates candidate actions from states.
Subclasses: 
\code{ConcatPolicy} (chain-of-thought), 
\code{RAPPolicy} (sub-question decomposition), 
\code{ToolUsePolicy} (ReAct-style workflow), 
\code{EnvGroundedPolicy} (environment actions).

\item \textbf{RewardModel} (general interface): 
Evaluates action quality for search guidance.
Subclasses: 
\code{GenerativePRM} (LLM-based scoring), 
\code{RLHFlowPRM} (trained reward model), 
\code{EnvGroundedPRM} (environment evaluation).

\item \textbf{Transition} (general interface): 
Executes actions and produces new states.
Subclasses: 
\code{ConcatTransition} (append reasoning), 
\code{RAPTransition} (answer sub-questions), 
\code{ToolUseTransition} (execute tools), 
\code{BlocksWorldTransition} (simulate environment).
\end{itemize}

These components compose into agents (MCTS, BFS, ReAct, EnvChain). 
Chain and tree methods share the same Policy and Transition—
tree search simply adds a RewardModel for path selection.

% each component is defined for all task instances of one task-type
Most components are designed for a general task type 
(as are the prompts described below).
They declare a \code{TASK\_TYPE} class constant 
(e.g., \code{'language\_grounded'}, \code{'tool\_use'}, 
\code{'env\_grounded'}).
For example, both math reasoning and commonsense reasoning 
can use the same components and prompts.

% Flexible Custom Components
However, component design is not limited to the predefined types. 
For task instances requiring specialized behavior, 
developers can create task-instance-specific components 
with \code{TASK\_TYPE = None}.
The only example in our package is \code{BlocksWorldTransition}, 
which implements BlocksWorld-specific state parsing and goal checking.



\paragraph{lits.prompts: Task-Instance-Prioritized Fallback (Goal 2).}
LiTS uses a centralized \code{PromptRegistry} to manage prompts 
for all LLM-based components, 
enabling prompt reuse and customization.
Components use two prompt types: 
\code{task\_prompt\_spec} (system instructions) and 
\code{usr\_prompt\_spec} (user message templates).

The registry supports a fallback lookup priority: 
explicit parameter $\rightarrow$ \code{task\_name} $\rightarrow$ 
\code{TASK\_TYPE} $\rightarrow$ default.
This allows users to:
(1) reuse general task-type prompts for new task instances 
(e.g., a new math dataset can use \code{language\_grounded} prompts), or
(2) register task-instance-specific prompts when needed.
Task-instance-specific components should set \code{TASK\_TYPE = None}
to skip the \code{TASK\_TYPE} fallback, 
avoiding potential mismatch between prompts and parsing logic.
