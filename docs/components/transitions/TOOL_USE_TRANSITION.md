# ToolUseTransition

## Type Signature

```python
class ToolUseTransition(Transition[ToolUseState, ToolUseAction]):
    """Transition model that materializes tool observations for ToolUsePolicy-driven search."""
```

**Key Points:**
- **StateT**: `ToolUseState` - A trajectory of `ToolUseStep` objects
- **ActionT**: `ToolUseAction` - A JSON string representing a tool call
- **Not** `ToolUseStep` - The transition receives only the action, not the full step

## Interface Methods

### `__init__(tools, observation_on_error)`

Initialize the transition with available tools.

**Parameters:**
- `tools` (list): List of tool instances (e.g., `BaseTool` subclasses)
- `observation_on_error` (str): Error message prefix when tool execution fails (default: "Tool execution failed.")

**Example:**
```python
from lits.components.transition.tool_use import ToolUseTransition
from lits.tools import CalculatorTool, SearchTool

tools = [CalculatorTool(), SearchTool()]
transition = ToolUseTransition(
    tools=tools,
    observation_on_error="Tool execution failed."
)
```

### `init_state() -> ToolUseState`

Initialize an empty state for starting a new trajectory.

**Returns:**
- `ToolUseState`: Empty trajectory state

**Example:**
```python
state = transition.init_state()
assert len(state) == 0
```

### `step(state, action, ...) -> Tuple[ToolUseState, dict]`

Execute a tool action and return the updated state.

**Parameters:**
- `state` (ToolUseState): Current trajectory state
- `action` (ToolUseAction): Tool action to execute (JSON string)
- `query_or_goals` (str, optional): Query context for logging
- `query_idx` (int, optional): Query index for logging
- `from_phase` (str, optional): Algorithm phase description (e.g., "expand", "simulate")

**Returns:**
- Tuple of `(new_state, aux_dict)` where:
  - `new_state` (ToolUseState): Updated state with executed step appended
  - `aux_dict` (dict): Auxiliary data, e.g., `{"confidence": 1.0}`

**Flow:**
1. Create a new state by copying the current state
2. Execute the tool action via `execute_tool_action()`
3. Construct a `ToolUseStep` with action and observation
4. Append the step to the new state
5. Return the new state and auxiliary data

**Example:**
```python
from lits.structures import ToolUseAction

# Action generated by policy
action = ToolUseAction('{"action": "calculator", "action_input": {"expression": "2+2"}}')

# Execute action
new_state, aux = transition.step(
    state=current_state,
    action=action,
    query_or_goals="What is 2+2?",
    query_idx=0
)

# Check result
assert len(new_state) == len(current_state) + 1
assert new_state[-1].action == action
assert new_state[-1].observation == "Result: 4"
assert aux["confidence"] == 1.0
```

### `is_terminal(state, ...) -> bool`

Check if the state is terminal (has reached a final answer).

**Parameters:**
- `state` (ToolUseState): Current trajectory state
- `query_or_goals` (str, optional): Query context
- `fast_reward` (float, optional): Fast reward score (unused in this implementation)
- `query_idx` (int, optional): Query index for logging
- `from_phase` (str, optional): Algorithm phase description

**Returns:**
- `bool`: True if the last step contains a final answer, False otherwise

**Logic:**
```python
if not state:
    return False
last = state[-1]
return bool(last.get_answer())
```

**Example:**
```python
# State without answer
state = ToolUseState([
    ToolUseStep(action=action1, observation="Result: 4")
])
assert not transition.is_terminal(state, query_or_goals="What is 2+2?")

# State with answer
state.append(ToolUseStep(answer="The answer is 4"))
assert transition.is_terminal(state, query_or_goals="What is 2+2?")
```


