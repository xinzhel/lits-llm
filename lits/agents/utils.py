import json
import ast
import re
from typing import List, Callable, Optional
from lits.utils.json_parser import parse_json_string

def extract_tag_content(text: str, tag: str) -> list[str]:
    """
    Extracts all contents enclosed within a specific XML-like tag.
    Example: extract_tag_content(s, "think") → ["reasoning text", "more reasoning"]
    """
    pattern = fr"<{tag}>(.*?)</{tag}>"
    return re.findall(pattern, text, flags=re.DOTALL)

def make_tag_extractor(tag: str) -> Callable[[str], List[str]]:
    """
    Returns a function that extracts all contents enclosed within a fixed XML-like tag.
    
    Example:
        extract_think = make_tag_extractor("think")
        extract_think("...<think>abc</think>...")  # → ["abc"]
    """
    pattern = re.compile(fr"<{tag}>(.*?)</{tag}>", flags=re.DOTALL)

    def extractor(text: str) -> List[str]:
        return pattern.findall(text)

    return extractor

def extract_from_triple_dots(action_str: str) -> list[str]:
    """ 
    Extracts the content between triple dots (```).
    Example:
    ```
    $JSON_BLOB
    ```
    """
    # Clean up escaped newlines or single quotes if needed
    cleaned = action_str.strip().strip("`")
    return cleaned

def execute_tool_action(action_data: str, tools: list):
    """
    Parse and execute an LLM-generated JSON tool action.

    Args:
        action_data (str): The raw JSON string generated by the model.
        tools (list): A list of available tool instances (BaseTool subclasses).

    Returns:
        Any: The tool's output (the observation).
    """
    # --- 1. Parse JSON safely ---
    parsed_action = parse_json_string(action_data)

    # --- 2. Validate required fields ---
    if "action" not in parsed_action or "action_input" not in parsed_action:
        raise ValueError(f"Invalid tool call format: {parsed_action}")

    tool_name = parsed_action["action"]
    action_input = parsed_action["action_input"]

    # --- 3. Find tool by name ---
    tool = next((t for t in tools if t.name == tool_name), None)
    if tool is None:
        raise ValueError(f"No tool found with name '{tool_name}'")

    # --- 4. Execute tool ---
    try:
        if hasattr(tool, "_run"):
            result = tool._run(**action_input)
        elif hasattr(tool, "__call__"):
            result = tool(**action_input)
        else:
            raise AttributeError(f"Tool {tool_name} has no callable method.")
    except Exception as e:
        raise RuntimeError(f"Error executing tool '{tool_name}': {e}")

    # --- 5. Return observation ---
    return result
